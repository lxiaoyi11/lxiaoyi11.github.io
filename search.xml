<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机操作系统</title>
      <link href="/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/03/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h1><h2 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h2><h3 id="1-操作系统的目标"><a href="#1-操作系统的目标" class="headerlink" title="1.操作系统的目标"></a>1.操作系统的目标</h3><p><strong>在操作系统上配置操作系统，其主要目标是：方便性，有效性，可扩充性和开放性</strong></p><ul><li><p>方便性：系统使用编译命令将用户采用高级语言书写的程序翻译成机器代码，或者直接通过OS所提供的各种命令操纵计算机</p></li><li><p>有效性：提高了系统资源的利用率和吞吐量</p></li><li><p>可扩充性：无结构→模块化结构→层次化结构→微内核结构</p></li><li><p>​                    微内核结构能方便地增添新的功能和模块，以及对原来的功能和模块进行修改，具有很好的可扩充性</p></li><li><p>开放性：指系统能遵循世界标准规范，特别是遵循开放系统互连OSI国际标准</p></li></ul><h3 id="2-操作系统的作用"><a href="#2-操作系统的作用" class="headerlink" title="2.操作系统的作用"></a>2.操作系统的作用</h3><p>（<strong>1）OS作为用户和计算机硬件系统之间的接口</strong></p><p>​            用户使用计算机的方式：命令方式，系统调用方式，图标-窗口方式</p><p><strong>（2）OS作为计算机系统资源的管理者</strong></p><table><thead><tr><th align="center"><strong>处理机管理</strong></th><th align="center"><strong>用于分配和控制处理机</strong></th></tr></thead><tbody><tr><td align="center"><strong>存储器管理</strong></td><td align="center"><strong>主要负责内存的分配和回收</strong></td></tr><tr><td align="center"><strong>I&#x2F;O设备管理</strong></td><td align="center"><strong>负责I&#x2F;O设备的分配（回收）与操纵</strong></td></tr><tr><td align="center"><strong>文件管理</strong></td><td align="center"><strong>用于实现对文件的存取，共享和保护</strong></td></tr></tbody></table><p><strong>（3）OS实现了对计算机资源的抽象</strong></p><p>​            在裸机上铺设的I&#x2F;O软件隐藏了I&#x2F;O设备的具体细节，向上提供了一组抽象的I&#x2F;O设备</p><h3 id="3-推动操作系统发展的主要动力"><a href="#3-推动操作系统发展的主要动力" class="headerlink" title="3.推动操作系统发展的主要动力"></a>3.推动操作系统发展的主要动力</h3><ul><li>不断提高的计算机资源利用率</li><li>方便用户</li><li>器件的不算更新换代</li><li>计算机体系结构的不断发展</li><li>不断提出新的应用需求</li></ul><h3 id="4-操作系统的发展过程"><a href="#4-操作系统的发展过程" class="headerlink" title="4.操作系统的发展过程"></a>4.操作系统的发展过程</h3><h4 id="（1）未配置操作系统的计算机系统"><a href="#（1）未配置操作系统的计算机系统" class="headerlink" title="（1）未配置操作系统的计算机系统"></a><strong>（1）未配置操作系统的计算机系统</strong></h4><table><thead><tr><th align="center"><strong>人工操作方式（存在人机矛盾→严重降低了计算机资源的利用率）</strong></th><th align="center"><strong>用户独占全机</strong></th></tr></thead><tbody><tr><td align="center"></td><td align="center"><strong>CPU等待人工操作</strong></td></tr><tr><td align="center"><strong>脱机输入&#x2F;输出（Off-Line O&#x2F;I）方式</strong></td><td align="center"><strong>减少了CPU的空闲时间</strong></td></tr><tr><td align="center"></td><td align="center"><strong>提高了I&#x2F;O速度</strong></td></tr></tbody></table><h4 id="（2）单道批处理系统"><a href="#（2）单道批处理系统" class="headerlink" title="（2）单道批处理系统"></a><strong>（2）单道批处理系统</strong></h4><ul><li><p>处理过程：先把作业以脱机的方式输入到磁带上，并在系统中配上监督程序（Monitor），在它的控制下，使这批作业一个接一个地连续处理，<u>虽然系统对作业的处理使成批进行的，但是在内存中始终只保持一道作业。</u></p></li><li><p>缺点：（1）内存中只有一道程序，该程序在运行中发出请求后，CPU便处于等待状态</p><p>​            （2）I&#x2F;O设备的低速</p></li></ul><h4 id="（3）多道批处理系统"><a href="#（3）多道批处理系统" class="headerlink" title="（3）多道批处理系统"></a><strong>（3）多道批处理系统</strong></h4><ul><li><p>基本概念：在该系统中，用户所提交的作业先存放在外存上，并排成一个队列，称为”后备队列“。然后由作业调度程序按一定的算法，从后备队列中选择若干个作业调入内存，使他们共享CPU和系统中的各种资源</p></li><li><p>优点：a.资源利用率高</p><p>​            b.系统的吞吐量大</p></li><li><p>缺点：a.平均周转时间长</p><p>​            b.无交互能力：用户一旦把作业提交给系统后，直至作业完成，用户都不能与自己的作业进行交互，修改和调试程序都不                                            方便</p></li><li><p>需要处理的问题：</p></li></ul><p>​            a.处理机争用问题</p><p>​            b.内存分配和保护问题</p><p>​            c. I&#x2F;O设备分配问题</p><p>​            d.文件的组织和管理问题</p><p>​            e.作业管理问题</p><p>​            f.用户与系统的接口问题</p><h4 id="（4）分时系统"><a href="#（4）分时系统" class="headerlink" title="（4）分时系统"></a><strong>（4）分时系统</strong></h4><ul><li><p>及时接收：配置多路卡，实现粉饰多路复用</p><p>​                    配置缓冲区，用来暂存用户键入的命令（或数据）</p></li><li><p>及时处理：采用作业直接进入内存</p><p>​                    采用轮转运行方式</p></li><li><p>分时系统的特征：</p><p>多路性：允许多个用户共享一台主机</p><p>独立性：每个用户在各自的终端上进行操作彼此之间互不干扰</p><p>及时性：用户的请求在很短的时间内获得响应</p><p>交互性:用户可以在终端与系统进行广泛的人机对话</p></li></ul><h4 id="（5）实时系统"><a href="#（5）实时系统" class="headerlink" title="（5）实时系统"></a><strong>（5）实时系统</strong></h4><p>最主要特征：将时间作为参数，它必须对所接收到的某些信号做出”及时“或”实时“的反映</p><p>实时系统的类型：</p><ul><li><p>​                               a. 工业（武器）控制系统</p></li><li><p>​                                b. 信息查询系统</p></li><li><p>​                                c. 多媒体系统</p></li><li><p>​                                d. 嵌入式系统</p></li></ul><p>实时任务的类型：</p><table><thead><tr><th align="center"><strong>周期性实时任务</strong></th><th align="center"><strong>指定它在指定循环执行，以便周期性的控制外部设备</strong></th></tr></thead><tbody><tr><td align="center"><strong>非周期性实时任务</strong></td><td align="center"><strong>无明显的周期性</strong></td></tr></tbody></table><table><thead><tr><th><strong>硬实时任务</strong></th><th><strong>系统必须满足任务对截止时间的要求，否则可能出现难以预测的后果</strong></th></tr></thead><tbody><tr><td><strong>软实时任务</strong></td><td><strong>联系一个截止时间，但并不严格，偶尔错过了任务的截止时间，对系统产生的影响也不会太大</strong></td></tr></tbody></table><p>✨实时系统与分时系统相比具有<u>高度可靠性</u>，因为任何差错都可能带来无法预料的灾难性后果，因此，在实时系统中，往往都采用了多级容错措施来保障系统的安全性及数据的安全性</p><h3 id="5-微机操作系统的发展"><a href="#5-微机操作系统的发展" class="headerlink" title="5.微机操作系统的发展"></a>5.微机操作系统的发展</h3><p>定义：配置在微型机上的操作系统称为微机操作系统</p><p>按运行方式分类：</p><ul><li>单用户单任务操作系统：只允许一个用户上机，且只允许用户程序作为一个任务运行</li><li>单用户多任务操作系统：只允许一个用户上机，但允许用户把程序分为若干个任务，使他们并发执行，有效地改善了系统的性能</li><li>多用户多任务操作系统：允许多个用户通过各自的终端，使用同一台机器，共享主机系统中的各种资源，而每个用户程序又可以进一步分为几个任务，使他们能并发执行，从而进一步提供资源利用率和系统吞吐量</li></ul><h3 id="6-操作系统的基本特性"><a href="#6-操作系统的基本特性" class="headerlink" title="6.操作系统的基本特性"></a>6.操作系统的基本特性</h3><p>操作系统共同的基本特征：并发，共享，虚拟，异步</p><h4 id="（1）并发（Concurrence）"><a href="#（1）并发（Concurrence）" class="headerlink" title="（1）并发（Concurrence）"></a><strong>（1）并发（Concurrence）</strong></h4><p>并发和并行的区别：</p><table><thead><tr><th align="center"><strong>并行</strong></th><th align="center"><strong>两个或多个事件在同一时刻发生</strong></th></tr></thead><tbody><tr><td align="center"><strong>并发</strong></td><td align="center"><strong>两个或多个事件在同一时间间隔发生</strong></td></tr></tbody></table><p>进程：指在系统中能独立运行并作为资源分配的基本单位</p><p>✨多个进程之间可以并发执行和交换信息</p><h4 id="（2）共享（Sharing）"><a href="#（2）共享（Sharing）" class="headerlink" title="（2）共享（Sharing）"></a><strong>（2）共享（Sharing）</strong></h4><p>在OS环境下的资源共享（或资源复用）是指系统中的资源可供内存中多个并发执行的进程共同使用</p><p>实现资源共享的方式：</p><ul><li>互斥共享方式：在一段时间内只允许一个进程访问</li><li>同时访问方式：在宏观上是“同时”，在微观上这些进程对该资源的访问是交替进行的</li></ul><h4 id="（3）虚拟（Virtual）"><a href="#（3）虚拟（Virtual）" class="headerlink" title="（3）虚拟（Virtual）"></a><strong>（3）虚拟（Virtual）</strong></h4><p>定义：在OS中，把通过某种技术将一个<u>物理实体</u>变为若干个<u>逻辑上的对应物</u>的功能称为虚拟</p><p>实现虚拟的技术：</p><table><thead><tr><th align="center"><strong>时分复用技术</strong></th><th align="center"><strong>利用处理机的空闲时间运行其他程序，提高了处理机的利用率</strong></th></tr></thead><tbody><tr><td align="center"><strong>空分复用技术</strong></td><td align="center"><strong>利用存储器的空闲空间分区域存放和运行其它的多道程序，以此来提高内存的利用率</strong></td></tr></tbody></table><h4 id="（4）异步（Asynchronism）"><a href="#（4）异步（Asynchronism）" class="headerlink" title="（4）异步（Asynchronism）"></a>（4）异步（Asynchronism）</h4><p>异步即不确定性，指进程的执行顺序和执行的时间具有不确定性，因此难以重新系统在某个时刻的状态</p><h3 id="7-操作系统的主要功能"><a href="#7-操作系统的主要功能" class="headerlink" title="7.操作系统的主要功能"></a>7.操作系统的主要功能</h3><h4 id="（1）处理机管理"><a href="#（1）处理机管理" class="headerlink" title="（1）处理机管理"></a>（1）处理机管理</h4><p><strong>处理机管理的主要功能有：创建和撤销进程，对诸多进程的运行进行协调，实现进程之间的信息交换，以及按照一定算法把处理及分配给进程</strong></p><ul><li><p>进程控制：为作业创建进程，撤销（终止）已结束的进程，以及控制进程在运行过程中的状态转换</p></li><li><p>进程同步：该机制的主要任务是为多个进程（含线程）的运行进行协调</p><p>​                    常用的协调方式：进程互斥方式：指诸进程在对临界资源进行访问时，应采用互斥方式</p><p>​                                                    进程同步方式：指在相互合作去完成共同任务的诸进程间，由同步机构对它们的执行次序加以协调</p></li><li><p>进程通信：实现相互合作进程之间的信息交换</p></li><li><p>调度：作业调度：（外存→内存）</p><p>​            进程调度：从进程的就绪队列中按照一定的算法选出一个进程，将处理及分配给它，并为它设置运行现场，使其投入执行</p></li></ul><h4 id="（2）存储器管理"><a href="#（2）存储器管理" class="headerlink" title="（2）存储器管理"></a>（2）存储器管理</h4><p><strong>存储器管理的主要功能：对内存的分配和回收，内存保护，地址映射和内存扩充等</strong></p><ul><li><p>内存分配：</p><p>​        主要任务：</p></li><li><ul><li><p>​                            a.为每道程序分配内存空间，使它们“各得其所”</p></li><li><p>​                            b. 提高存储器的利用率，尽量减少不可用的内存空间（碎片）</p></li><li><p>​                            c. 允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要</p></li></ul></li><li><p>​        实现内存分配的方式：</p></li><li><ul><li>​                                                a.静态分配方式</li><li>​                                                b. 动态分配方式</li></ul></li><li><ul><li>内存保护：</li></ul></li><li><p>​        主要任务：</p></li><li><p>​                            a. 彼此互不干扰</p></li><li><p>​                            b.相互保密</p></li><li><p>地址映射：</p></li></ul><p>​        将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址</p><ul><li>内存扩充：</li></ul><p>​        内存扩充并非使从物理上去扩大内存的容量，而是借助与虚拟存储技术，从逻辑上扩充内存容量</p><h4 id="（3）设备管理"><a href="#（3）设备管理" class="headerlink" title="（3）设备管理"></a>（3）设备管理</h4><p><strong>设备管理具有缓冲管理，设备分配和设备处理以及虚拟设备等功能</strong></p><ul><li><p>缓冲管理</p><p>​        在I&#x2F;O设备和CPU之间引入缓冲，则可有效地缓和CPU和I&#x2F;O设备速度不匹配的矛盾，提高CPU的利用率，进而提高系统的吞吐量</p><p>​        可通过<u>增加缓冲区容量</u>的办法来改善系统的性能</p></li><li><p>常见的缓冲区机制：</p><p>​                    a. 单缓冲机制</p><p>​                    b.双缓冲机制：能实现双向同时传送数据</p><p>​                    c.公用缓冲池机制：能供多个设备同时使用</p></li><li><p>设备分配：</p><p>​        设备分配的基本任务使根据用户进程的I&#x2F;O请求，系统现有资源情况以及按照某种设备分配策略，为之分配所需的设备</p></li><li><p>设备处理：</p></li></ul><p>​        设备处理程序（设备驱动程序）的基本任务是<u>实现CPU和设备控制器站之间的通信</u>，即由CPU向设备控制器发出I&#x2F;O命令，要求它完成指定的I&#x2F;O操作；反之，由CPU接收从控制器发来的中断请求，并给予迅速的响应和相应的而处理</p><h4 id="（4）文件管理"><a href="#（4）文件管理" class="headerlink" title="（4）文件管理"></a>（4）文件管理</h4><p><strong>文件管理应具有对文件存储空间的管理，目录管理，文件的读&#x2F;写管理以及文件的共享和保护等功能</strong></p><h4 id="（5）操作系统与用户之间的接口"><a href="#（5）操作系统与用户之间的接口" class="headerlink" title="（5）操作系统与用户之间的接口"></a>（5）操作系统与用户之间的接口</h4><p>用户接口：</p><ul><li><p>​        a. 联机用户接口：为联机用户提供，用户可用过先后键入不同命令的方式来实现对作业的控制，直到作为完成</p></li><li><p>​        b. 脱机用户接口：为批处理作业的用户提供</p></li><li><p>​        c. 图形用户接口：用户可通过菜单（或对话框）用移动鼠标玄策菜单项的方式取代命令的键入，以方便，快捷地完成对应用程序和文                                        件的操作</p></li></ul><p>程序接口：</p><p>​        程序接口是为用户程序在执行中访问系统资源而设置的，<u>是用户程序取得操作系统服务的唯一途径</u></p><h4 id="（6）现在操作系统的新功能"><a href="#（6）现在操作系统的新功能" class="headerlink" title="（6）现在操作系统的新功能"></a>（6）现在操作系统的新功能</h4><p>系统安全：认证技术，密码技术，访问控制技术，反病毒技术</p><p>网络的功能和服务：</p><ul><li>​                    a.网络通信：用于在源主机和目标主机之间，实现无差错的数据传输</li><li>​                    b.资源管理：对网络中的共享资源实施有效的管理，协调诸用户对共享资源的使用，保证数据的安全性和一致性</li><li>​                    c. 应用互操作：实现信息的互通性和信息的互用性</li></ul><p>支持多媒体：</p><ul><li>​            a.接纳控制功能</li><li>​            b. 实时调度</li><li>​            c. 多媒体文件的存储</li></ul><h2 id="第二章-进程的描述与控制"><a href="#第二章-进程的描述与控制" class="headerlink" title="第二章 进程的描述与控制"></a>第二章 进程的描述与控制</h2><h3 id="2-1前趋图和程序执行"><a href="#2-1前趋图和程序执行" class="headerlink" title="2.1前趋图和程序执行"></a>2.1前趋图和程序执行</h3><p>前趋图：有向无循环图，用于描述程序执行的先后顺序</p><p>初始结点：在前趋图中，把没有前趋的节点叫做初始结点</p><p>终止结点：在前趋图中，把没有后继的节点叫做终止节点</p><p>程序顺序执行的特征：</p><ul><li><p>（1）顺序性：指处理机严格地按照程序所规定的顺序执行，即每一操作必须在下一个操作开始之前结束</p></li><li><p>（2）封闭性：指程序的执行结果不受外界因素影响</p></li><li><p>（3）可再现性：指只要程序执行时的环境和初始调价相同，当程序重复执行是，无论是怎么执行，都会获得相同结果</p></li></ul><p>程序并发执行：</p><p>（1）定义：若干个程序段同时在系统钟运行，这些程序的执行在时间上是重迭的，一个程序段的执行尚未结束，另一个程序段的执行已经开始，即使这种重迭是很小的，也称这几个程序段是并发执行的</p><p>（2）特征：</p><ul><li><p>​                a. 间断性：并发执行的程序之间形成了相互制约的关系，相互制约将导致并发程序具有“执行–暂停–执行”这种间断性</p></li><li><p>​                b. 失去封闭性：由于系统中的各种资源被共享，导致程序在运行时，环境必然会受其他程序的影响</p></li><li><p>​                c. 无可再现性：由于失去了封闭性，导致计算结果会与程序的执行速度有关，所以失去了可再现性</p></li></ul><h3 id="2-2-进程的描述"><a href="#2-2-进程的描述" class="headerlink" title="2.2 进程的描述"></a>2.2 进程的描述</h3><p>进程控制块（Process Control Block, PCB）:</p><p>​        为了使参与并发执行的每个程序（含数据）都能独立地运行，在操作系统中为之配置一个专门的数据结构，称为进程控制块（PCB）</p><p>进程的定义：</p><p>​        有程序段，相关的数据段和PCB三部分构成了进程实体（又称进程映像），简称为进程</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础课</title>
      <link href="/2022/02/28/Linux%E5%9F%BA%E7%A1%80%E8%AF%BE/"/>
      <url>/2022/02/28/Linux%E5%9F%BA%E7%A1%80%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础课"><a href="#Linux基础课" class="headerlink" title="Linux基础课"></a>Linux基础课</h1><h2 id="一-常用文件命令管理"><a href="#一-常用文件命令管理" class="headerlink" title="一.常用文件命令管理"></a>一.常用文件命令管理</h2><ul><li><p>ctrl +c  ： ( 1 ) 杀掉某个程序</p><p> ​                     ( 2 ) 取消命令，并且换</p></li><li><p>ctrl +u ：清空本行命令</p></li><li><p>tab键 ：可以补全命令和文件名</p></li><li><p>ls : 列出当前目录下所有文件</p></li><li><p>pwd ：显示当前路径</p></li><li><p>ls 文件名 -l ：看某一个文件的详细信息</p></li><li><p>ls 文件名 -hl ：人性化输出，使得输出的信息让人看起来更加的方便</p></li><li><p>ls -a ：显示隐藏文件（当文件名以点开头会被隐藏起来） 会显示当前目录和上层目录</p></li><li><p>ls -A ：显示隐藏文件，但不会显示当前目录和上层目录</p></li><li><p>.  ：一个点表示当前目录   </p></li><li><p>.. ：表示上层目录</p></li><li><p>cd ：进入某个目录   </p></li><li><p>cd .. ：返回上层目录    </p></li><li><p>cd - ：返回上一回呆过的目录</p></li><li><p>cp ：复制+粘贴+重命名    例：cp a b -r ：将a文件夹整个复制到b</p></li><li><p>mkdir ：创建一个文件夹</p></li><li><p>rm XXX ：删除普通文件      </p></li><li><p>rm XXX -r ：删除文件夹</p></li><li><p>touch ：创建一个文件</p></li><li><p>mv ：剪切+粘贴，还有重命名    </p></li><li><p>mv XXX YYY ：将XXX移动到YYY</p></li><li><p>cat ：展示文件内容</p><hr></li></ul><h2 id="二-tmux"><a href="#二-tmux" class="headerlink" title="二.tmux"></a>二.tmux</h2><h3 id="1-tmux的作用："><a href="#1-tmux的作用：" class="headerlink" title="1 tmux的作用："></a><strong>1 tmux的作用：</strong></h3><p>​        （1）分屏</p><p>​        （2）允许断开Terminal连接后，继续运行进程</p><h3 id="2-tmux的结构："><a href="#2-tmux的结构：" class="headerlink" title="2 tmux的结构："></a><strong>2 tmux的结构：</strong></h3><p>​    一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane</p><h3 id="3-tmux的操作："><a href="#3-tmux的操作：" class="headerlink" title="3 tmux的操作："></a><strong>3 tmux的操作：</strong></h3><p>​        （1）tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框</p><p>​        （2）先按ctrl+a，再按%：将当前pane半分成左右两个pane</p><p>​        （3）先按ctrl+a，再按“：将当前pane半分成上下两个pane</p><p>​        （4）ctrl+d：关闭当前的Pane，如果当前window的所有pane均已关闭，则自动关闭window，如果当前session下的所有window均已关闭，则自动关闭session</p><p>​        （5）先按ctrl+a，再按方向键：选择当前的pane</p><p>​        （6）鼠标拖动pane之间的分割线，可以调整分割线的位置</p><p>​        （7）按住ctrl+a的同时按方向键，可以调整分割线的位置</p><p>​        （8）先按ctrl+a，再按z：将当前的pane全屏&#x2F;取消全屏</p><p>​        （9）先按ctrl+a，再按d：挂起当前的session</p><p>​        （10）tmux a ：打开之前挂起的session</p><p>​        （11）先按ctrl+a，再按s：选择其他session</p><ul><li><p>​                    方向键上：选择上一项，session&#x2F;window&#x2F;pane</p></li><li><p>​                    方向键下：选择下一项，session&#x2F;window&#x2F;pane</p></li><li><p>​                    方向键左：展开当前项，session&#x2F;window</p></li><li><p>​                    方向键右：闭合当前项，session&#x2F;window</p></li></ul><p>​        （12）先按ctrl+a，再按c：再当前的session中创建一个新的window</p><p>​        （13）先按ctrl+a，再按w：选择其他的window</p><p>​        （14）先按ctrl+a，再按PageUp：翻阅当前pane内的内容</p><p>​        （15）在tmux中选中文本时，需要按住shift键</p><h2 id="三-vim"><a href="#三-vim" class="headerlink" title="三.vim"></a>三.vim</h2><h3 id="1-功能："><a href="#1-功能：" class="headerlink" title="1.功能："></a>1.功能：</h3><ul><li>命令行模式下的文本编辑器</li><li>根据文件扩展名自动判别编程语言，支持代码缩进，代码高亮等功能</li><li>使用方式：vim filename（如果已有该文件，则打开它；如果没有该文件，则打开一个新的文件夹，并命名为filename）</li></ul><h3 id="2-模式："><a href="#2-模式：" class="headerlink" title="2.模式："></a>2.模式：</h3><ul><li>一般命令模式：默认模式，可以复制，粘贴，删除文本</li><li>编辑模式：在一般命令模式下按i，会进入编辑模式；按esc会退出编辑模式回到一般命令模式</li><li>命令行模式：在一般命令模式下按：&#x2F;  ？三个字母中的任意一个，会进入命令行模式，可以查找，替换，保存，退出，配置编辑器等</li></ul><h3 id="3-操作"><a href="#3-操作" class="headerlink" title="3.操作"></a>3.操作</h3><ul><li><p>i ：进入编辑模式</p></li><li><p>esc：进入一般命令模式</p></li><li><p>h：光标向左移动一个字符</p></li><li><p>j：光标向下移动一个字符</p></li><li><p>k：光标向上移动一个字符</p></li><li><p>l：光标向右移动一个字符</p></li><li><p>n<space>：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符（在一般命令模式下）</p></li><li><p>0或功能键[Home]：光标移到本行开头</p></li><li><p>$或功能键[End]：光标移到本行末尾</p></li><li><p>G：光标移到最后一行</p></li><li><p>:n或nG：n代表数字，光标移动到第n行</p></li><li><p>gg：光标移动到第一行，相当于1G</p></li><li><p>n<Enter>：n为数字，光标向下移动n行</p></li><li><p>&#x2F;word：向光标之下寻找第一个值为word的字符串</p></li><li><p>?word：向光标之上寻找第一个值为word的字符串</p></li><li><p>n：重复前一个查找操作</p></li><li><p>N：反向重复前一个查找操作</p></li><li><p>:n1,n2s&#x2F;word1&#x2F;word2&#x2F;g：n1,n2为数字，在第n1行和n2行之间寻找word1这个字符串，并将该字符串替换为word2</p></li><li><p>:1,$s&#x2F;word1&#x2F;word2&#x2F;g：将全文的word1替换为word2</p></li><li><p>:1,$s&#x2F;word1&#x2F;word2&#x2F;gc：将全文的word1替换为word2，并且在替换前要求用户确认</p></li><li><p>d：删除选中的文本</p></li><li><p>dd：删除当前行</p></li><li><p>y：复制选中的文本</p></li><li><p>yy：复制当前行</p></li><li><p>p：将复制的数据在光标的下一个位置粘贴</p></li><li><p>u：撤销</p></li><li><p>ctrl+r：取消撤销</p></li><li><p>shift+&gt;：将选中的文本整体向右移动</p></li><li><p>shift+&lt;：将选中的文本整体向左移动</p></li><li><p>:w ：保存</p></li><li><p>:w!  ：强制保存</p></li><li><p>:q  ：退出</p></li><li><p>:q!  ：强制退出</p></li><li><p>:wq   ：保存并退出</p></li><li><p>:set nu  ：显示行号</p></li><li><p>:set nonu  ：隐藏行号</p></li><li><p>:set paste  ：设置成粘贴模式，取消代码自动缩进</p></li><li><p>:set nopaste  ：取消粘贴模式，开启代码自动缩进</p></li><li><p>gg&#x3D;G：将全文代码格式化</p></li><li><p>:noh ：关闭查找关键词高亮</p></li><li><p>ctrl+q  ：当vim卡死时，可以取消当前正在执行的命令</p></li></ul><h3 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4.异常处理"></a>4.异常处理</h3><p>每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件，如果打开某文件时，该文件的swp文件已存在，则会报错，此时解决方案有两种：</p><ul><li><p>找到正在打开该文件的程序，并退出</p></li><li><p>直接删掉该swp文件即可</p><hr></li></ul><h2 id="三-shell语法"><a href="#三-shell语法" class="headerlink" title="三.shell语法"></a>三.shell语法</h2><h2 id="1-概论"><a href="#1-概论" class="headerlink" title="1.概论"></a>1.概论</h2><p>shell是通过命令行与操作系统沟通的语言</p><p>shell脚本可以直接在命令行中执行，也可以将一套逻辑组织成一个文件，方便复用</p><p>Linux中常见的shell脚本有很多，常见的有：</p><ul><li>Boume Shell(&#x2F;usr&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;sh)</li><li>Boume Again Shell(&#x2F;bin&#x2F;bash)</li><li>C Shell(&#x2F;usr&#x2F;bin&#x2F;csh)</li><li>K Shell(&#x2F;sur&#x2F;bin&#x2F;ksh)</li><li>…</li></ul><p>Linux系统中一般默认使用bash，所以接下来的是bash中的语法</p><p>文件开头需要写#！&#x2F;bin&#x2F;bash，指明bash为脚本解释器</p><p><strong>脚本示例</strong></p><p>新建一个test.sh文件，内容如下：</p><blockquote><p>#!  &#x2F;bin&#x2F;bash</p><p>echo “Hello  World!”</p></blockquote><p><strong>运行方式</strong></p><p>作为可执行文件（需要权限）</p><blockquote><p>chmod  +x  test.sh    &#x2F;&#x2F;使脚本具有可执行权限</p><p>.&#x2F;test.sh                &#x2F;&#x2F;当前路径下执行</p><p>Hello World!            &#x2F;&#x2F;脚本输出</p><p>&#x2F;home&#x2F;acs&#x2F;test.sh                &#x2F;&#x2F;绝对路径下执行</p><p>Hello World!            &#x2F;&#x2F;脚本输出</p><p>~&#x2F;test.sh                    &#x2F;&#x2F;家目录路径下执行</p><p>Hello World!            &#x2F;&#x2F;脚本输出</p></blockquote><p>用解释器执行（不需要权限也可以）</p><blockquote><p>bash test.sh                </p><p>Hello World1            &#x2F;&#x2F;脚本输出</p></blockquote><h3 id="2-注释"><a href="#2-注释" class="headerlink" title="2.注释"></a>2.注释</h3><p><strong>单行注释</strong></p><p>每行中#之后的内容均是注释</p><p><strong>多行注释</strong></p><blockquote><p>:&lt;&lt;EOF                    &#x2F;&#x2F;其中EOF可以换成其他字符串</p><p>第一行注释</p><p>第二行注释</p><p>第三行注释</p><p>EOF</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>读书分享</title>
      <link href="/2022/02/27/%E6%91%98%E6%8A%84/"/>
      <url>/2022/02/27/%E6%91%98%E6%8A%84/</url>
      
        <content type="html"><![CDATA[<ul><li><p>“想要精通某事，就必须对它真正上心；想在某个领域出类拔萃，必须为之痴迷。很对人说他们渴望成就伟大，却不愿为此做出必要牺牲。他们关心的事太多，无论重要与否，都浪费了太多精力，这没什么不好，归根结底，伟大并非常人所能企及。”<br>                                                                                                                                                                                                    —-科比</p></li><li><p>“黑夜里的你，拥有看不见的世界，和清晰的自己。”                                                                                                        </p><p>​                                                                                                                                                                                             —-博尔赫斯</p></li><li><p>“玫瑰即玫瑰，花香无意义。”                                                                                                                                                </p><p>​                                                                                                                                                                                                —-博尔赫斯</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/02/26/hello-world/"/>
      <url>/2022/02/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>STL</title>
      <link href="/2022/01/12/STL/"/>
      <url>/2022/01/12/STL/</url>
      
        <content type="html"><![CDATA[<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="1-1STL的基本概念"><a href="#1-1STL的基本概念" class="headerlink" title="1.1STL的基本概念"></a>1.1STL的基本概念</h2><p>（1）STL(Standard Template Library)标准模板库</p><p>（2）STL从广义上分为：容器（container）算法（algorithm）迭代器（iterator）</p><p>（3）容器和算法之间通过迭代器进行无缝衔接</p><hr><h2 id="1-2STL的六大组件"><a href="#1-2STL的六大组件" class="headerlink" title="1.2STL的六大组件"></a>1.2STL的六大组件</h2><p>STL 的六大组件：容器，算法，迭代器，仿函数，适配器（配接器），空间配置器</p><p>（1）容器：各种数据结构，如vector,list deque,set ,map等，用来存放数据</p><p>（2）算法：各种常用的算法，如sort,find,copy,for_each等</p><p>（3）迭代器：扮演了容器和算法之间的胶合剂</p><p>（4）仿函数：行为类似函数，可作为算法的某种策略</p><p>（5）适配器：一种用来修饰容器或者仿函数或迭代器接口的东西</p><p>（6）空间配置器：负责空间的配置和管理</p><hr><h2 id="1-3STL中容器，算法，迭代器"><a href="#1-3STL中容器，算法，迭代器" class="headerlink" title="1.3STL中容器，算法，迭代器"></a>1.3STL中容器，算法，迭代器</h2><p><strong>容器</strong>：置物之所也    分为序列式容器和关联式容器</p><p><strong>序列式容器</strong>：强调值的排序，序列式容器中的每个元素均有固定的位置</p><p><strong>关联式容器</strong>：二叉树结构，各元素之间没有严格的物理上的顺序关系</p><p><strong>算法</strong>：问题之解法也  有限的步骤解决逻辑或数学上的问题    分为质变运算和非质变运算</p><p><strong>质变运算</strong>：指运算过程中会更改区间内的元素的内容，例如：拷贝，替换，删除等</p><p><strong>非质变运算</strong>：指运算过程中不会更改区间内的元素内容，例如：查找，计数，遍历，寻找极值等</p><p><strong>迭代器</strong>：容器和算法之间的胶合剂</p><p>迭代器提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴漏该容器的内部表示方式</p><p>每个容器都有自己专属的迭代器        迭代器的使用类似于<strong>指针</strong></p><p>常用的容器中迭代器种类为双向迭代器和随机迭代器：（1）双向迭代器：读写操作，能向前和向后操作，支持++，——；</p><p>​                                                                                            （2）随机迭代器：读写操作，可以跳跃的方式访问任意数据，功能最强的迭代器</p><p>​                                </p><hr><h2 id="2-算法，容器，迭代器的初识"><a href="#2-算法，容器，迭代器的初识" class="headerlink" title="2.算法，容器，迭代器的初识"></a>2.算法，容器，迭代器的初识</h2><p>容器：vector </p><p>算法：for_each</p><p>迭代器：vector<int>::iterator</p><hr><h2 id="2-1vector-容器嵌套容器"><a href="#2-1vector-容器嵌套容器" class="headerlink" title="2.1vector 容器嵌套容器"></a>2.1vector 容器嵌套容器</h2><p>两个容器嵌套相当于一个<strong>二维数组</strong>，对两个容器相遍历相当于遍历创建的二维数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">void text ()</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt;v;//创建一个大容器</span><br><span class="line">    //下面为创建四个小容器</span><br><span class="line">    vector&lt;int&gt;v1;</span><br><span class="line">    vector&lt;int&gt;v2;</span><br><span class="line">    vector&lt;int&gt;v3;</span><br><span class="line">    vector&lt;int&gt;v4;</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;4;i++)//向小容器中存入数据，此时小容器并没有放入大容器中</span><br><span class="line">    &#123;</span><br><span class="line">        v1.push_back(i+1);</span><br><span class="line">        v2.push_back(i+2);</span><br><span class="line">        v3.push_back(i+3);</span><br><span class="line">        v4.push_back(i+4);</span><br><span class="line">    &#125;</span><br><span class="line">    //将4个小容器放入大容器中</span><br><span class="line">        v.push_back(v1);</span><br><span class="line">        v.push_back(v2);</span><br><span class="line">        v.push_back(v3);</span><br><span class="line">        v.push_back(v4);</span><br><span class="line">        </span><br><span class="line">        for(vector&lt;vector&lt;int&gt;&gt;::iterator it=v.begin();it!=v.end;it++)//遍历大容器</span><br><span class="line">        &#123;</span><br><span class="line">        for(vector&lt;int&gt;::iterator vit=(*it).begin();vit!=(*it).end;vit++)//遍历小容器</span><br><span class="line">        &#123;</span><br><span class="line">        cout&lt;&lt;*vit;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">text();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="3-1-string-类"><a href="#3-1-string-类" class="headerlink" title="3.1  string 类"></a>3.1  string 类</h2><h3 id="3-1-1-string-基本概念"><a href="#3-1-1-string-基本概念" class="headerlink" title="3.1.1 string 基本概念"></a>3.1.1 string 基本概念</h3><p>本质：string 是一个c++风格的字符串，本质是一个类</p><p><strong>string和char*区别：</strong></p><p>​                                char*是一个指针；</p><p>​                                string是一个类，类内部封装了char<em>，管理这个字符串，是一个char</em>型的容器</p><p><strong>特点：</strong></p><p>string 类内部封装了很多成员方法，例如：find,  copy,  delete,  insert.</p><p>string 管理chao*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p><hr><h3 id="3-1-2-string-构造函数"><a href="#3-1-2-string-构造函数" class="headerlink" title="3.1.2 string 构造函数"></a>3.1.2 string 构造函数</h3><p>​        string (  );    &#x2F;&#x2F;创建一个空的字符串</p><p>​        eg.   string  str1 ;   &#x2F;&#x2F;默认构造</p><p>​        string  (  const   char*   s) ;    &#x2F;&#x2F;使用字符串S初始化</p><p>​        eg. const  char *  str &#x3D; “  hello  world!  “;</p><p>​                string   str2 ( str1 ) ;  </p><p>​        string  (  const   string&amp;  str  ) ;    &#x2F;&#x2F;使用一个string初始化另一个string对象</p><p>​        eg. string  s3 ( s2 ) ;</p><p>​        string (int  n,  char   c ) ;    &#x2F;&#x2F;使用n个字符c初始化</p><p>​        eg.  string  s4 ( 10, ‘a’ ) ;</p><hr><h3 id="3-1-3-string-赋值操作"><a href="#3-1-3-string-赋值操作" class="headerlink" title="3.1.3  string 赋值操作"></a>3.1.3  string 赋值操作</h3><p>​        string&amp;  operator &#x3D; ( const  char*  s ) ;  &#x2F;&#x2F;char* 类型字符串赋值给当前的字符串</p><p>​        eg.  string  str1 ; </p><p>​                str1 &#x3D; “ hello  world ! “ ; </p><p>​        string&amp;  operator &#x3D; ( const  string  s )  ;   &#x2F;&#x2F;把字符串s赋给当前的字符串</p><p>​        eg.   string  str2 ;</p><p>​                str2 &#x3D; str1 ;</p><p>​    </p><p>​        string&amp; operator &#x3D; ( char  c )  ;   &#x2F;&#x2F;把字符赋值给当前的字符串</p><p>​        eg.  string  str3 ; </p><p>​                str3 &#x3D; ‘a’ ;</p><p>​        string&amp; assign ( const  char* s ) ;   &#x2F;&#x2F;把字符串s赋给当前的字符串</p><p>​        eg.  string  str4;</p><p>​                str4.assign ( “hello”) ;</p><p>​        string&amp; assign ( const  char* s ,int  n ) ;   &#x2F;&#x2F;把字符串s的前n个字符赋给当前的字符串</p><p>​        eg.  string  str5 ;</p><p>​                str5.assign( “hello”, 3 ) ;</p><p>​        string&amp; assing ( const  string &amp;s ) ;    &#x2F;&#x2F;把字符串s 赋给当前的字符串</p><p>​        eg.  string str6 ; </p><p>​                str6.assign ( str5 ) ;</p><p>​        string&amp; assign ( int  n,  char  c ) ;    &#x2F;&#x2F;用n 个字符赋给当前的字符串</p><p>​        eg.  string  str7 ; </p><p>​                str7.assign ( 10 ,  ‘a’ ) ;</p><hr><h3 id="3-1-4-string-字符串拼接"><a href="#3-1-4-string-字符串拼接" class="headerlink" title="3.1.4  string  字符串拼接"></a>3.1.4  string  字符串拼接</h3><p>功能：</p><p>​        实现在字符串末尾拼接字符串</p><p>函数原型：</p><p>​        string&amp;  operator +&#x3D; ( const  char*  str ) ;                      &#x2F;&#x2F;重载+&#x3D;操作符</p><p>​        eg.  string  str1 &#x3D;  “ I “ ;</p><p>​                str1+&#x3D;  “ want to sleep “ ;</p><p>​        string&amp;  operator +&#x3D; ( const char c ) ;           &#x2F;&#x2F;重载+&#x3D;操作符</p><p>​        string&amp;  operator +&#x3D;  ( const  string&amp;  str ) ;             &#x2F;&#x2F;重载+&#x3D;操作符</p><p>​        eg.  string  str2 ;</p><p>​                str2 +&#x3D; str1;  </p><p>​        string&amp;  append ( const  char  *s ) ;            &#x2F;&#x2F;把字符串s连接到当前的字符串</p><p>​        eg.  string str3 ;</p><p>​                str3.append ( “ BBQ” ) ;</p><p>​        string&amp;  append ( const  char  *s ,  int  n ) ;          &#x2F;&#x2F;把字符串s的前n个字符连接到当前的字符串</p><p>​        eg.  string  str4;</p><p>​                str4.append( “ pizza “ , 5 ) ;</p><p>​        string&amp;  append ( const  string  &amp;s ) ;             &#x2F;&#x2F;等同于 string &amp;   operator +&#x3D; ( const  string  &amp;str ) ;</p><p>​        string&amp;  append （const  string  &amp;s ,  int  pos  ,  int  n ）;         &#x2F;&#x2F;将字符串s中的从pos位置开始的n 个字符连接到字符串的结尾</p><p>​        eg.  string  str5 ;</p><p>​                str5.append ( “ pizza, hamburger” , 7 , 9 ) ;</p><hr><h3 id="3-1-5-string-查找和替换"><a href="#3-1-5-string-查找和替换" class="headerlink" title="3.1.5 string 查找和替换"></a>3.1.5 string 查找和替换</h3><p>功能 : </p><p>​        查找：查找指定字符串是否存在</p><p>​        替换：在指定的位置替换字符串</p><p>函数原型：</p><p>​        int  find ( const  string&amp;  str  ,int  pos &#x3D; 0 ) const ;      &#x2F;&#x2F;查找str第一次出现的位置</p><p>​        int find ( const  char*  s , int  pos &#x3D; 0 ) const ;      &#x2F;&#x2F;查找s第一次出现的位置，从pos 开始找</p><p>​        int find ( const  char*  s  , int  pos ,  int  n ) const ;       &#x2F;&#x2F;从pos 的位置开始找S的前n 个字符第一次出现的位置</p><p>​        int  find ( const  char  c  ,int  pos &#x3D; 0 ; ) const ;            &#x2F;&#x2F;查找字符c第一次出现的位置</p><p>​       int rfind ( const  string&amp;  str , int  pos &#x3D; npos ) const； &#x2F;&#x2F;从右开始查找字符串str第一次出现的位置  </p><p>​                                                                                                       &#x3D;&#x3D;从左查找str最后一次出现的位置</p><p>​        int rfind ( const char* s ,int  pos , int  n ) const ;          &#x2F;&#x2F;查找字符串s前n 个字符最后一次出现的位置</p><p>​        int  rfind ( const char  c  ,int  pos &#x3D;0  ) const ;            &#x2F;&#x2F;查找字符c最后一次出现的问题</p><p>​        string&amp;  replace ( int   pos , int  n , const  srting&amp;  str ) ;       &#x2F;&#x2F;替换从pos开始的n个字符为字符串str</p><p>​        string&amp;  replace ( int  pos , int  n , const  char*  s ) ;          &#x2F;&#x2F;替换从pos 开始的n个字符为字符串s</p><hr><h3 id="3-1-6-string-字符串比较"><a href="#3-1-6-string-字符串比较" class="headerlink" title="3.1.6 string  字符串比较"></a>3.1.6 string  字符串比较</h3><p>功能：</p><p>​        字符串之间的比较</p><p>比较方式：</p><p>​        字符串的比较是按字符ASCII码进行对比</p><p>​        &#x3D;  返回 0  </p><p>​        &gt;  返回 1</p><p>​        &lt;  返回-1</p><p>函数原型：</p><p>​        int  compare ( const  string  &amp;s ) const ;        &#x2F;&#x2F;与字符串s比较</p><p>​        int  compare ( const  char*  s ) const ;           &#x2F;&#x2F;与字符串s比较</p><p>​        eg .  string  str1 &#x3D; “ hello “;</p><p>​                string  str2 &#x3D; “ hello “;</p><p>​                if ( str1.compare ( str2 ) &#x3D;&#x3D; 0 ) ;</p><p>​                cout&lt;&lt;”s1和s2 一样大” ；                    </p><hr><h3 id="3-1-7-string-字符存取"><a href="#3-1-7-string-字符存取" class="headerlink" title="3.1.7 string 字符存取"></a>3.1.7 string 字符存取</h3><p>string 中单个字符的存取方式有两种</p><p>​        （1）通过[]方式存取字符</p><p>​        （2）通过at 方式存取字符</p><p>eg.  通过[]方式存取字符：</p><p>​            取：    for ( int i &#x3D; 0 ; i&lt; str.size ( ) ; i++)</p><p>​        {</p><p>​                    cout &lt;&lt; str [ i ] ;</p><p>​        }</p><p>​            更改：  str [ i ] &#x3D; ‘ x ‘ ;</p><p>​        通过at的方式存取字符：</p><p>​            取：     for ( int i &#x3D; 0 ; i &lt; str.size ( ) ; i ++)</p><p>​                    {</p><p>​                    cout  &lt;&lt; str.at ( i ) ;</p><p>​                    }</p><p>​            更改：str.at ( i ) &#x3D; ‘ x ‘ ;</p><hr><h3 id="3-1-8-string插入和删除"><a href="#3-1-8-string插入和删除" class="headerlink" title="3.1.8 string插入和删除"></a>3.1.8 string插入和删除</h3><p>函数原型：</p><p>​            string&amp;  insert ( int  pos ,  const  char*  s ) ;           &#x2F;&#x2F;插入字符串</p><p>​            string&amp;  insert ( int  pos , const  string&amp;  str ) ;         &#x2F;&#x2F;插入字符串</p><p>​            string&amp;  insert ( int  pos , int  n,  char  c ) ;                 &#x2F;&#x2F;在指定位置插入n个字符</p><p>​            string&amp;  erase ( int  pos ,  int n &#x3D; npos ) ;                    &#x2F;&#x2F;删除从pos开始的n个字符</p><p>eg .     str &#x3D; “ hello “;</p><p>​            str. insert ( 1 , “ mmm “ ) ;</p><p>​            str . erase ( 1 ,   “mmm” ) ;</p><hr><h3 id="3-1-9-string-子串"><a href="#3-1-9-string-子串" class="headerlink" title="3.1.9 string 子串"></a>3.1.9 string 子串</h3><p>功能：</p><p>​        从字符串中获取想要的子串</p><p>函数原型：</p><p>​        string  substr （ int  pos &#x3D; 0 , int  n &#x3D; npos ）const ;       &#x2F;&#x2F;返回由pos开始的n个字符组成的字符串</p><p>eg.   string  email &#x3D; “ <a href="mailto:&#104;&#101;&#x6c;&#x6c;&#x6f;&#x40;&#x73;&#105;&#110;&#x61;&#x2e;&#99;&#111;&#109;">&#104;&#101;&#x6c;&#x6c;&#x6f;&#x40;&#x73;&#105;&#110;&#x61;&#x2e;&#99;&#111;&#109;</a>“ ; </p><p>​        int  pos &#x3D; email.find ( “ @ “) ;</p><p>​        string  username &#x3D; email.substr ( 0, pos ) ;</p><p>​        cout&lt;&lt;username ; </p><hr><h2 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h2><h3 id="3-2-1vector容器的基本概念"><a href="#3-2-1vector容器的基本概念" class="headerlink" title="3.2.1vector容器的基本概念"></a>3.2.1vector容器的基本概念</h3><p>功能：</p><p>​        vector数据结构和数组非常相似，也称为单端数组，可以在尾部进行插入删除操作</p><p>vector和普通数组的区别：</p><p>​        数组是静态空间，而vector 可以动态扩展</p><p>动态扩展：</p><p>​        并不是在原空间之后续接新空间，而是将原数据拷贝新空间，释放原空间</p><p>v.begin ( ) 指向第一个元素的位置</p><p>v.end ( ) 指向最后一个元素的下一个位置</p><p>push_back 在尾部插入</p><p>pop_back在尾部删除</p><p>vector 的迭代器是支持随机访问的迭代器</p><h3 id="3-2-2-vector构造函数"><a href="#3-2-2-vector构造函数" class="headerlink" title="3.2.2 vector构造函数"></a>3.2.2 vector构造函数</h3><p>函数原型：</p><p>​        vector<T> v ;                    &#x2F;&#x2F;采用模板实现类实现，默认构造函数</p><p>​        vector(&lt;v.begin ( ) ,v.end ( ) ) ;            &#x2F;&#x2F;将[v.begin（），v.end）区间中的元素拷贝给本身</p><p>​        vector ( n ,  elem ) ;                &#x2F;&#x2F;构造函数将n个elem拷贝给本身</p><p>​        vector ( const  vector  &amp;vec) ;             &#x2F;&#x2F;拷贝构造函数</p><p>​        </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span>;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;v)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">    <span class="comment">//通过区间的方式进行构造</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">v2</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line">    <span class="comment">//n个elem方式构造</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">v3</span>(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printVector</span>(v3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt;::iterator it = v.<span class="built_in">begin</span>(); it != v.<span class="built_in">end</span>(); it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">text</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-3-vector-赋值操作"><a href="#3-2-3-vector-赋值操作" class="headerlink" title="3.2.3 vector 赋值操作"></a>3.2.3 vector 赋值操作</h3><p>函数原型：</p><p>​            vector&amp;  operator&#x3D; ( const  vector  &amp;vec ) ;            &#x2F;&#x2F;重载等号操作符</p><p>​            assign ( v.begin ( )  , v.end ( ) ) ;            &#x2F;&#x2F;将[v.begin( ) , v.end ( ) ) 区间中的数据拷贝赋值给本身</p><p>​            assign ( n , elem ) ;                    &#x2F;&#x2F;将n个elem拷贝赋值给本身</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator it=v.<span class="built_in">begin</span>();it!=v.<span class="built_in">end</span>();it++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">text</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v1;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v2;<span class="comment">//重载等号操作符</span></span><br><span class="line">    v2=v1;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v3;<span class="comment">//将区间中的数据元素拷贝给v3</span></span><br><span class="line">    v3.<span class="built_in">assign</span>(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printVector</span>(v3);<span class="comment">//将10个100赋值给v4</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;v4;</span><br><span class="line">    v4.<span class="built_in">assign</span>(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">text</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p><h3 id="3-2-4-vector-容量和大小"><a href="#3-2-4-vector-容量和大小" class="headerlink" title="3.2.4 vector 容量和大小"></a>3.2.4 vector 容量和大小</h3><p>函数原型：</p><p>​        empty(  ) ;                &#x2F;&#x2F;判断容器是否为空</p><p>​        capacity(  ) ;            &#x2F;&#x2F;容器的容量</p><p>​        size(  ) ;                &#x2F;&#x2F;返回容器中元素的个数</p><p>​        resize( int  num ) ;            &#x2F;&#x2F;重新指定容器的长度为num, 若容器变长，则以默认值填充新位置</p><p>​                                                   &#x2F;&#x2F;若容器变短，则末尾超出容器长度的元素被删除</p><p>​        resize( int  num , elem ) ;                 &#x2F;&#x2F;重新指定容器的长度为num，若容器边长，则以elem值填充新位置</p><p>​                                                                    &#x2F;&#x2F;若容器变短，则末尾超过容器长度的元素被删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">void text()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v1;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;v1.capacity()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;v1.size()&lt;&lt;endl;</span><br><span class="line">if(v1.empty())</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;容器为空！&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;&quot;容器不为空！&quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">v1.resize(15,100);</span><br><span class="line">for(vector&lt;int&gt;::iterator it=v1.begin();it!=v1.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">text();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-5-vector-插入和删除"><a href="#3-2-5-vector-插入和删除" class="headerlink" title="3.2.5 vector 插入和删除"></a>3.2.5 vector 插入和删除</h3><p>函数原型：</p><p>​            push_back( ele ) ;            &#x2F;&#x2F;尾部插入元素ele</p><p>​            pop_back ( ) ;                &#x2F;&#x2F;删除最后一个元素</p><p>​            insert ( const _ iterator  pos ,  ele ) ;            &#x2F;&#x2F;迭代器指向位置Pos插入元素ele</p><p>​            insert ( const_iterator  pos ,  int  num,  ele) ;             &#x2F;&#x2F;迭代器指向位置pos插入num个ele元素</p><p>​            erase ( const _itreator  pos) ;                 &#x2F;&#x2F;删除迭代器指向的元素</p><p>​            erase ( const_iterator  start ,  const_iterator  end ) ;            &#x2F;&#x2F;删除迭代器指向的从start到end之间的元素</p><p>​            clear ( ) ;              &#x2F;&#x2F;清空迭代器中的所有元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">void printVector(vector&lt;int&gt;&amp;v)</span><br><span class="line">&#123;</span><br><span class="line">for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void text()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v1;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line">v1.pop_back();</span><br><span class="line">printVector(v1);</span><br><span class="line">v1.insert(v1.begin(),2,88);</span><br><span class="line">printVector(v1);</span><br><span class="line">v1.erase(v1.begin()+1);</span><br><span class="line">printVector(v1);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">text();</span><br><span class="line">return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-6-vector数据存取"><a href="#3-2-6-vector数据存取" class="headerlink" title="3.2.6  vector数据存取"></a>3.2.6  vector数据存取</h3><p>函数原型：</p><p>​        at ( int  idx ) ;            &#x2F;&#x2F;返回索引idx所指的数据</p><p>​        operator[ ] ;            &#x2F;&#x2F;返回索引idx所指的数据</p><p>​        front ( ) ;                &#x2F;&#x2F;返回容器中第一个元素</p><p>​        back ( ) ;                 &#x2F;&#x2F;返回容器中最后一个元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">void text()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v;</span><br><span class="line">for(int i =0; i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">for(int i=0;i&lt;v.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;v.at(i)&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">for(int i =0; i&lt;v.size();i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;v[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;v.front()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;v.back()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">text();</span><br><span class="line">return 0 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-7-vector容器互换"><a href="#3-2-7-vector容器互换" class="headerlink" title="3.2.7 vector容器互换"></a>3.2.7 vector容器互换</h3><p><strong>功能描述：</strong></p><p>​        实现两个容器内元素进行互换</p><p><strong>函数原型：</strong></p><p>​        swap( vec ) ;            &#x2F;&#x2F;将vector与本身的元素互换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include&lt;vector&gt;</span><br><span class="line"></span><br><span class="line">void printVector(vector&lt;int&gt;&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void text()</span><br><span class="line">&#123;</span><br><span class="line">vector&lt;int&gt;v1;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">vector&lt;int&gt;v2;</span><br><span class="line">for (int i = 10; i &gt; 0; i--)</span><br><span class="line">&#123;</span><br><span class="line">v2.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v2);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v1.swap(v2);</span><br><span class="line">printVector(v1);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">printVector(v2);</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">text();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-deque容器"><a href="#3-3-deque容器" class="headerlink" title="3.3  deque容器"></a>3.3  deque容器</h2><h3 id="3-3-1deque容器基本概念"><a href="#3-3-1deque容器基本概念" class="headerlink" title="3.3.1deque容器基本概念"></a>3.3.1deque容器基本概念</h3><p><strong>功能：</strong></p><p>​        双端数组，可以对头端进行插入删除操作</p><p><strong>deque和vector区别</strong></p><p>​        （1）vector如果对头部进行插入删除需要移动数据元素，效率低，数据越大，效率越低</p><p>​        （2）deque相对而言，对头部的插入删除速度会比vector快</p><p>​        （3）vector访问元素的速度会比deque快（和两者的内部实现有关）</p><p><strong>deque内部工作原理：</strong></p><p>​            deque内部有一个中控器，维护每段缓冲区中的内容，缓冲区中存放真实数据</p><p>​            中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p><p>注：deque的迭代器也是支持随机访问的</p><h3 id="3-3-2-deque-构造函数"><a href="#3-3-2-deque-构造函数" class="headerlink" title="3.3.2 deque 构造函数"></a>3.3.2 deque 构造函数</h3><p>函数原型：</p><p>​        deque<T>deqT;                &#x2F;&#x2F;默认构造形式</p><p>​        deque ( begin , end  ) ;          &#x2F;&#x2F;构造函数将[begin，end)区间中的元素拷贝给本身                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </p><p>​        deque ( n , elem ) ;                 &#x2F;&#x2F;构造函数，将n个elem拷贝给本身</p><p>​        deque ( const  deque &amp;deq ) ;            &#x2F;&#x2F;拷贝构造函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line"></span><br><span class="line">void printDeque(const deque&lt;int&gt;&amp; T)//现在为只读状态，不可以写</span><br><span class="line">&#123;</span><br><span class="line">for (deque&lt;int&gt;::const_iterator it = T.begin(); it != T.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">//此处不能对*it赋值  eg.*it=100;就是错误的</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void text()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt;T;</span><br><span class="line">for (int i = 0; i &lt; 10; i++)</span><br><span class="line">&#123;</span><br><span class="line">T.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(T);</span><br><span class="line">deque&lt;int&gt;T1(T.begin(), T.end());</span><br><span class="line">printDeque(T1);</span><br><span class="line">deque&lt;int&gt;T2(2, 48);</span><br><span class="line">printDeque(T2);</span><br><span class="line">deque&lt;int&gt;T3(T2);</span><br><span class="line">printDeque(T3);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">text();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h3><p>函数原型：</p><p>​        deque&amp;  opretor&#x3D;( const  deque  &amp;deq ) ;             &#x2F;&#x2F;重载等号操作符</p><p>​        assign ( begin,end ) ;                 &#x2F;&#x2F;将[begin,end)区间中的数据拷贝赋值给本身</p><p>​        assign ( n, elem) ;            &#x2F;&#x2F;将n个elem拷贝赋值给本身</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line"></span><br><span class="line">void prineDeque(const deque&lt;int&gt;T)</span><br><span class="line">&#123;</span><br><span class="line">for(deque&lt;int&gt;::const_iterator it=T.begin();it!=T.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void text()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt;T1;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">T1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(T1);</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">deque&lt;int&gt;T2;</span><br><span class="line">T2=T1;</span><br><span class="line">printDeque(T2);</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">deque&lt;int&gt;T3;</span><br><span class="line">T3.assign(T1.begin(),T1.end());</span><br><span class="line">printDeque(T3);</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">deque&lt;int&gt;T4;</span><br><span class="line">T4.assign(10,100);</span><br><span class="line">printDeque(T4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">text();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-4-deque-大小操作"><a href="#3-3-4-deque-大小操作" class="headerlink" title="3.3.4 deque 大小操作"></a>3.3.4 deque 大小操作</h3><p>注：deque没有容量可言，它可以无限插入，只需要在中控器里加一个指向插入元素的地址即可</p><p>函数原型：</p><p>​        deque.empty ( ) ;            &#x2F;&#x2F;判断容器是否为空</p><p>​        deque.size( ) ;            &#x2F;&#x2F;返回容器中的元素个数</p><p>​        deque.resize( num ) ;            &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置</p><p>​                                                            &#x2F;&#x2F;若容器变短，则末尾超出容器长度放入元素被删除</p><p>​        deque.resize ( num , elem );            &#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置</p><p>​                                                                    &#x2F;&#x2F;若容器变短，则末尾超出容器长度的元素被删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#include&lt;deque&gt;</span><br><span class="line"></span><br><span class="line">void printDeque(const deque&lt;int&gt; &amp;D)</span><br><span class="line">&#123;</span><br><span class="line">for(deque&lt;int&gt;::const_iterator it=D.begin();it!=D.end();it++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;*it&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void text()</span><br><span class="line">&#123;</span><br><span class="line">deque&lt;int&gt;D1;</span><br><span class="line">for(int i=0;i&lt;10;i++)</span><br><span class="line">&#123;</span><br><span class="line">D1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(D1);</span><br><span class="line">if(D1.empty())  cout&lt;&lt;&quot;D1为空！&quot;;</span><br><span class="line">else  cout&lt;&lt;&quot;D1不为空&quot;;</span><br><span class="line">cout&lt;&lt;D1.size();</span><br><span class="line">D1.resize(20,21);</span><br><span class="line">printDeque(D1);</span><br><span class="line">D1.resize(5);</span><br><span class="line">printDeque(D1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">text();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-5-deque-插入和删除"><a href="#3-3-5-deque-插入和删除" class="headerlink" title="3.3.5 deque 插入和删除"></a>3.3.5 deque 插入和删除</h3><p>函数原型：</p><p>​            push_back( elem ) ;                    &#x2F;&#x2F;在容器尾部插入一个数据</p><p>​            push_front( elem ) ;                    &#x2F;&#x2F;在容器头部插入一个数据</p><p>​            pop_back( );                    &#x2F;&#x2F;删除容器中最后一个元素</p><p>​            pop_back( ) ;                    &#x2F;&#x2F;删除容器第一个元素</p><p>​            insert ( pos , elem ) ;                 &#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，<strong>返回新数据的位置</strong></p><p>​            insert ( pos , n, elem ) ;             &#x2F;&#x2F;在pos位置插入n个elem数据，无返回值</p><p>​            insert ( pos , begin , end ) ;                    &#x2F;&#x2F;在pos位置插入[begin，end)区间的数据，无返回值</p><p>​            clear( ) ;                                     &#x2F;&#x2F;清空容器中所有的数据</p><p>​            erase( pos ) ;                        &#x2F;&#x2F;删除pos位置的数据，<strong>返回下一个数据的位置</strong></p><p>​            erase( begin ,  end ) ;                            &#x2F;&#x2F;删除[begin，end）区间的数据，<strong>返回下一个数据的位置</strong></p><h2 id="3-4-bitset"><a href="#3-4-bitset" class="headerlink" title="3.4  bitset"></a>3.4  bitset</h2><p>bitset是位操作的对象，值只有0或1，即false或true.内部维护了一个long 数组，初始只有一个long，所以bitst的最小的size是64，当随着存储的元素越来越多，bitset的内部会动态扩展，最终内部是由N个long 来存储。</p><h3 id="3-4-1构造函数"><a href="#3-4-1构造函数" class="headerlink" title="3.4.1构造函数"></a>3.4.1构造函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;4&gt;bitset1;  //无参构造，长度为4，默认每一位为0</span><br><span class="line">bitset&lt;8&gt;bitset2(12);   //长度为8，将12转化为二进制保存到后面，前面用0补充</span><br><span class="line"></span><br><span class="line">string s=&quot;100101&quot;;</span><br><span class="line">bitset&lt;10&gt;bitset3(s);    //长度为10，前面用0补充；</span><br><span class="line"></span><br><span class="line">char s2[]=&quot;10101&quot;;</span><br><span class="line">bitset&lt;13&gt;bitset4(s2);   //长度为13，前面用0补充</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;bitset1&lt;&lt;endl;    //0000</span><br><span class="line">cout&lt;&lt;bitset2&lt;&lt;endl;    //00001100</span><br><span class="line">cout&lt;&lt;bitset3&lt;&lt;endl;    //0000100101</span><br><span class="line">cout&lt;&lt;bitset4&lt;&lt;endl;    //0000000010101</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-4-2注意事项"><a href="#3-4-2注意事项" class="headerlink" title="3.4.2注意事项"></a>3.4.2注意事项</h3><p>1.bitset十进制输入进来以后直接用cout输出的是二进制，但是实际里面的二进制是倒序的。</p><p>   如果循环从0位输出到最后一位，输出的是倒序的。</p><p>​    由于二进制的表示形式是一种逆序的形式，若<strong>想实现二进制向十进制的转化，就要低位在前</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int bin2dec(const string &amp;bin)</span><br><span class="line">&#123;</span><br><span class="line">std::bitset&lt;8&gt;bs(bin.rbegin(),bin.rend());</span><br><span class="line">return bs.to_ulong();      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.用字符串构造的时候，字符串只能包含0或1，否则会抛出异常</p><p>​    构造时，需要在&lt;&gt;中表明bitset的大小（即size）</p><p>​    在进行有参构造时，如果参数的二进制表示比bitset的size小，前面用0补充，如果比bitset的size大，<strong>参数为整数时取后面的部分，参数为字符串时取前面的部分。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;2&gt; bitset1(12);　　//12的二进制为1100（长度为４），但bitset1的size=2，只取后面部分，即00</span><br><span class="line"></span><br><span class="line">string s = &quot;100101&quot;;　　</span><br><span class="line">bitset&lt;4&gt; bitset2(s);　　//s的size=6，而bitset的size=4，只取前面部分，即1001</span><br><span class="line"></span><br><span class="line">char s2[] = &quot;11101&quot;;</span><br><span class="line">bitset&lt;4&gt; bitset3(s2);　　//与bitset2同理，只取前面部分，即1110</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; bitset1 &lt;&lt; endl;　　//00</span><br><span class="line">cout &lt;&lt; bitset2 &lt;&lt; endl;　　//1001</span><br><span class="line">cout &lt;&lt; bitset3 &lt;&lt; endl;　　//1110</span><br></pre></td></tr></table></figure><h3 id="3-4-3可用的操作符"><a href="#3-4-3可用的操作符" class="headerlink" title="3.4.3可用的操作符"></a>3.4.3可用的操作符</h3><p>bitset对于二进制有位操作符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;4&gt;foo(string(&quot;1001&quot;));</span><br><span class="line">bitset&lt;4&gt;bar(string(&quot;0011&quot;));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo^=bar) &lt;&lt; endl;       // 1010 (foo对bar按位异或后赋值给foo)</span><br><span class="line">cout &lt;&lt; (foo&amp;=bar) &lt;&lt; endl;       // 0010 (按位与后赋值给foo)</span><br><span class="line">cout &lt;&lt; (foo|=bar) &lt;&lt; endl;       // 0011 (按位或后赋值给foo)</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo&lt;&lt;=2) &lt;&lt; endl;        // 1100 (左移２位，低位补０，有自身赋值)</span><br><span class="line">cout &lt;&lt; (foo&gt;&gt;=1) &lt;&lt; endl;        // 0110 (右移１位，高位补０，有自身赋值)</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (~bar) &lt;&lt; endl;           // 1100 (按位取反)</span><br><span class="line">cout &lt;&lt; (bar&lt;&lt;1) &lt;&lt; endl;         // 0110 (左移，不赋值)</span><br><span class="line">cout &lt;&lt; (bar&gt;&gt;1) &lt;&lt; endl;         // 0001 (右移，不赋值)</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo==bar) &lt;&lt; endl;       // false (0110==0011为false)</span><br><span class="line">cout &lt;&lt; (foo!=bar) &lt;&lt; endl;       // true  (0110!=0011为true)</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (foo&amp;bar) &lt;&lt; endl;        // 0010 (按位与，不赋值)</span><br><span class="line">cout &lt;&lt; (foo|bar) &lt;&lt; endl;        // 0111 (按位或，不赋值)</span><br><span class="line">cout &lt;&lt; (foo^bar) &lt;&lt; endl;        // 0101 (按位异或，不赋值)</span><br></pre></td></tr></table></figure><p>可以通过[ ]访问元素（类似数组），注意最低位下标位0；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;4&gt; foo (&quot;1011&quot;);</span><br><span class="line"> cout &lt;&lt; foo[0] &lt;&lt; endl;　　//1</span><br><span class="line"> cout &lt;&lt; foo[1] &lt;&lt; endl;　　//1</span><br><span class="line"> cout &lt;&lt; foo[2] &lt;&lt; endl;　　//0</span><br></pre></td></tr></table></figure><p>也可以通过这种方式对某一元素赋值。</p><h3 id="3-4-4可用函数"><a href="#3-4-4可用函数" class="headerlink" title="3.4.4可用函数"></a>3.4.4可用函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;8&gt;foo(&quot;10011011&quot;);</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;foo.count()&lt;&lt;endl;    //5    count函数用来求bitset中1的位数，foo中一共有5和1</span><br><span class="line">cout&lt;&lt;foo.size()&lt;&lt;endl;     //7    size函数用来求bitset的大小，一共有8位</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;foo.test(0)&lt;&lt;endl;     //true   test函数用来查下标的元素是0还是1，如果是0返回false,如果是1，返回true</span><br><span class="line">cout&lt;&lt;foo.test(2)&lt;&lt;endl;     //false</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;foo.any()&lt;&lt;endl;     //true   any函数用来检查bitset中是否有1</span><br><span class="line">cout&lt;&lt;foo.none()&lt;&lt;endl;     //false    none函数用来检查bitset中是否没有1</span><br><span class="line">cout&lt;&lt;foo.all()&lt;&lt;endl;      //false    all函数用来检查bitset中是否全部为1</span><br></pre></td></tr></table></figure><p>补充说明：</p><p>​            test函数会对下标越界作出检查，而通过[ ]则不能对下标越界作出检查，所以，在两种方式都通用的条件下，用test会更安全一些。另外，还有一些函数也会检查下标是否越界，如果越界就会抛出异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;8&gt; foo (&quot;10011011&quot;);</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;foo.flip(2)&lt;&lt;endl;     //10011111  flip函数传参数时，用于将参数位取反，本行代码将foo下标为2的0变为1，即0变1，1变0</span><br><span class="line">cout&lt;&lt;foo.flip()&lt;&lt;endl;      //01100000  flip函数不传参数时，将bitset中的每一位都取反</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;foo.set()&lt;&lt;endl;      //11111111   set函数不指定参数时，将bitset中的每一位都置为1</span><br><span class="line">cout&lt;&lt;foo.set(3,0)&lt;&lt;endl;     //11110111      set函数指定两个参数时，将第一位参数位的元素置为第二参数位的值，本行对foo操作相当于foo[3]=0;</span><br><span class="line">cout&lt;&lt;foo.set(3);//11111111    set函数只有一个参数时，将参数下标位置为1</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;foo.reset(3);//11110111   reset函数传一个参数时将参数下标处置为0</span><br><span class="line">cout&lt;&lt;foo.reset();//00000000    reset函数不穿参数时，将bitset中的每一位全部置为0</span><br></pre></td></tr></table></figure><p>还有一些转化类型的函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bitset&lt;8&gt; foo (&quot;10011011&quot;);</span><br><span class="line"></span><br><span class="line">string s=foo.to_string();//将bitset转换成string类型</span><br><span class="line">unsigned long a=foo.to_ulong();//将bitset转换成unsigned long类型</span><br><span class="line">unsigned long long b=foo.to_ullong();//将bitset转换成unsigned long long 类型</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
